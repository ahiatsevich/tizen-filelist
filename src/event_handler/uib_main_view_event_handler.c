/*******************************************************************************
 * This file was generated by UI Builder.
 * User should hand edit this file.
 ********************************************************************************/

#include "app_main.h"
#include "view_data.h"
#include "uib_app_manager.h"
#include "uib_views.h"
#include "uib_views_inc.h"
#include "fs-manager.h"
#include "logger.h"
#include "app-types.h"
#include "common-utils.h"
#include "model-utils.h"

typedef struct _uib_main_view_control_context {
	Elm_Genlist_Item_Class *itc;
} uib_main_view_control_context;

static uib_main_view_control_context context;

// traverse file hierarchy recursively
static int _get_file_list_recursively(fs_manager *manager,
		const char *root_dir_path, Eina_List **file_list);

// getlist utils
static void _genlist_item_style_init(Elm_Genlist_Item_Class **itc);

// getlist callbacks
static char * _genlist_text_get(void *data, Evas_Object *obj, const char *part);
static Evas_Object * _genlist_content_get(void *data, Evas_Object *obj,
		const char *part);

void main_view_main_view_onuib_view_create(uib_main_view_view_context *vc,
		Evas_Object *obj, void *event_info) {
	_genlist_item_style_init(&context.itc);

	if (vc->file_genlist) {
		int result;
		Eina_List *storage_list = NULL;

		result = fs_manager_get_storage_list(fs_manager_get_shared_manager(),
				&storage_list);
		RETM_IF(result != RESULT_TYPE_OK, "Fail to get storage list");

		const Eina_List *_s_list = NULL;
		storage_info *storage = NULL;

		EINA_LIST_FOREACH(storage_list, _s_list, storage)
		{
			Eina_List *file_list = NULL;

			node_info *storage_item = calloc(1, sizeof(node_info));
			storage_item->name = strdup("Internal Storage");
			storage_item->size_free = storage->size_availbale;
			storage_item->type = FILE_TYPE_STORAGE;
			Elm_Object_Item *node_item = elm_genlist_item_append(vc->file_genlist,
					context.itc, storage_item, NULL, ELM_GENLIST_ITEM_NONE,
					NULL, NULL);

			elm_object_item_data_set(node_item, storage_item);

			// find all files in storage
			result = _get_file_list_recursively(fs_manager_get_shared_manager(),
					storage->root_path, &file_list);

			if (result == RESULT_TYPE_OK) {
				Eina_List *_f_list = NULL;
				node_info *file_item = NULL;
				EINA_LIST_FOREACH(file_list, _f_list, file_item)
				{
					DBG("File: %s/%s", file_item->parent_path, file_item->name);

					Elm_Object_Item *node_item = elm_genlist_item_append(
							vc->file_genlist, context.itc, file_item, NULL,
							ELM_GENLIST_ITEM_NONE, NULL, NULL);

					elm_object_item_data_set(node_item, file_item);
				}
			}

			//common_util_clear_file_list(&file_list); // TODO: memory leak
		}

		common_util_clear_storage_list(&storage_list);
	}
}

void main_view_main_view_onuib_view_destroy(uib_main_view_view_context *vc,
		Evas_Object *obj, void *event_info) {
	free(context.itc);
}

int _get_file_list_recursively(fs_manager *manager, const char *root_dir_path,
		Eina_List **file_list) {
	RETVM_IF(!manager, RESULT_TYPE_INVALID_ARG, "File manager is NULL");
	RETVM_IF(!root_dir_path, RESULT_TYPE_INVALID_ARG, "Path is NULL");
	RETVM_IF(!file_list, RESULT_TYPE_INVALID_ARG, "File list is NULL");

	int result;
	Eina_List *node_list = NULL;

	result = fs_manager_get_file_list(fs_manager_get_shared_manager(),
			root_dir_path, &node_list);

	if (result == RESULT_TYPE_OK) {
		Eina_List *list = NULL;
		node_info *node = NULL;
		EINA_LIST_FOREACH(node_list, list, node)
		{
			if (node->type == FILE_TYPE_DIR) {
				result = _get_file_list_recursively(
						fs_manager_get_shared_manager(), node->full_path,
						file_list);
				if (result != RESULT_TYPE_OK) {
					break;
				}
			} else if (node->type != FILE_TYPE_NONE) {
				*file_list = eina_list_append(*file_list, node);
			}
		}
	}

	//common_util_clear_file_list(&node_list); // TODO: memory leak

	return result;
}

static void _genlist_item_style_init(Elm_Genlist_Item_Class **itc) {
	Elm_Genlist_Item_Class *itc_double_style = elm_genlist_item_class_new();
	itc_double_style->item_style = "2text.1icon.1";
	itc_double_style->func.text_get = _genlist_text_get;
	itc_double_style->func.content_get = _genlist_content_get;
	itc_double_style->decorate_item_style = NULL;
	itc_double_style->decorate_all_item_style = NULL;
	itc_double_style->func.state_get = NULL;
	itc_double_style->func.del = NULL;

	*itc = itc_double_style;
}

static char * _genlist_text_get(void *data, Evas_Object *obj, const char *part) {
	node_info* node = (node_info *) data;
	if (strcmp(part, "elm.text") == 0) {
		return strdup(node->name);
	} else if (strcmp(part, "elm.text.1") == 0) {
		char buf[256];
		size_t len;
		if (node->type == FILE_TYPE_STORAGE) {
			snprintf(buf, sizeof(buf), "Available: %ldKB",
					node->size_free / 1024);
		} else {
			snprintf(buf, sizeof(buf), "Size: %ldKB", node->size / 1024);
		}
		len = strlen(buf);
		buf[len - 1] = '\0';

		return strdup(buf);
	}

	return NULL;
}

static Evas_Object * _genlist_content_get(void *data, Evas_Object *obj,
		const char *part) {
	RETVM_IF(!data, NULL, "Data is NULL");

	return NULL;
}
